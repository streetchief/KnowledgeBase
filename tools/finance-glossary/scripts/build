#!/bin/bash
set -euo pipefail
IFS=$'\n\t'

append_to_markdown () {
    cat "$file" \
    | awk '
        /^# / {
            word = substr($0, 3)
        }
        /^## Definition/ {
            while (getline && $0 == "") {}
            def = $0
        }
        END {
            print word ": " def "\n"
        }
    ' >> "$targetFile"
}

glossaryDir="/knowledge/finance-glossary"
rootDir="$(pwd)"
sourceDir="$rootDir$glossaryDir"
buildDir="$rootDir/build"
buildType=${1:-"json"}
targetFilename="glossary.$buildType"
targetFile="$buildDir/$targetFilename"

echo "Building $buildType glossary..."

if [[  -f "$targetFile" ]]; then
    echo "Clearing existing glossary..."
    truncate --size=0 "$targetFile"
else 
    echo "Creating glossary file..."
    touch "$targetFile"
fi

echo "Appending data..."

# Markdown generation

if [[ "$buildType" == "md" ]]; then
    for file in "$sourceDir"/*; do
        append_to_markdown
    done
fi;

# JSON generation

if [[ "$buildType" == "json" ]]; then
    echo "[" > "$targetFile"

    for file in "$sourceDir"/*; do
        cat "$file" | "./tools/finance-glossary/scripts/md-to-json" >> "$targetFile"
    done

    # This is based on bytes and probably fails on windows due to line end difference.
    # Delete 1 byte for newline and 1 for trailing comma.
    truncate --size=-2 "$targetFile"

    {
        echo ""
        echo "]"
    } >> "$targetFile"
fi

echo "Done!"
